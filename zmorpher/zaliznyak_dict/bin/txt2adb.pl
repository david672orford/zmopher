#!/usr/bin/perl -w
# © Copyright 1999-2003 Juri Linkov <juri@jurta.org>
# License: GNU GPL 2

use utf8;
use open qw(:std :utf8);
#use locale;
use POSIX qw(locale_h strftime);

my $CURDATE = strftime('%Y-%m-%d', localtime);
my $PROGRAM = ($0 =~ /([^\/]*)$/)[0];
my $VERSION = "0.0.1dsc";

sub usage {
  warn "Запуск: $PROGRAM zaliz.txt >zaliz.adb\n";
  exit(1);
}

my $zaliz = shift || usage();
open(ZALIZ, "<:encoding(utf-8)", $zaliz) || die "Файл $zaliz не найден: $@";

#print <<HERE;
## $CURDATE $PROGRAM v$VERSION http://www.jurta.org/rus/zaliz/index.ru.html
#HERE

my $vml = 0; # multi-line variants
my $sort_order = " вар з3 з2 з слсч фр фк искл фп фн фз до осф ос сб гпс гпр гбл гмн гп гв ч3 ч2 чо чё ч п2ф п2 р2 у2 у1 и с2ч о рм р мн т2 т у с ";

while(<ZALIZ>) {
  next if /^#/;				# comment
  next if /^\s*$/;			# blank line
  chomp;

  my (%props, %fzprops, %fnprops);
  # $o - оригинальная строка (original)
  # $word - заглавное слово
  # $fp - форма предположительна
  # $fz - форма затруднительна
  # $fn - формы нет
  # $excp - исключение (exception)
  my ($word, $fp, $fz, $fn, $excp);
  my $o = $_;

  # варианты
  if(s{(?://|=)>}{})
    { $vml = 1 }
  elsif(s{<(?:=|//)}{})
    { $vml++ }
  elsif($vml)
    { $vml = 0 }
  if($vml)
    { $props{'вар'} = $vml }

  s/\s*$//;

  # Откусить заглавное слово и ударение заглавного слова
  if(s/^([^\d]+)\s+([\d.,]+)\s+//)
    {
    $word = $1;
    my $acc = $2;
    while($acc =~ s(,(\d+))())				# FIXME: simplify s expressions, figure out why
      { substr($word, $1-1, 1) =~ tr(е)(ё) }
    $props{'у'} = $acc;
    }
  else
    {
    warn "Неправильный формат строки: $o\n";
    next;
    }

  # фразеологизмы
  if(s/\s*%\s*(.*)$//) { $props{'фр'} = $1 }
  # факультативная часть индекса
  if(!m|@.*\[//| && s|\[//([^:]*)\]||) { $props{'фк'} = $1 }
  # глагол противоположного вида
  if(s/\s*\$\s*(.*)$//) { $props{'гпр'} = $1 }
  # дополнительные особенности в склонении/спряжении
  if(s/(?:,)?\s*\#(\d+)\s*//) { $props{'до'} = $1 }
  # морфологически нерегулярные формы
  if(s/\s*@\s*(.*)$//) {
    my $exc = $1;
    ($exc =~ s/^(\S+):/:/) && ($_ .= "0".$1);
    if($exc !~ /;/ && $exc =~ s/_исх\. форма нерегул\._//) {
      $excp = "{'ие'=>[{'с'=>'$word','у'=>'$props{'у'}'}]}";
    } else {
      #$excp = $lineh{$exc};
      #$excp or warn "Исключение не найдено в файле $x_subpatch: \@$exc\n";
      #(defined $excp) && ($exc eq $excp) && (undef $excp, 1) &&
      #  warn "Исключение заменяется старой строкой: \@$exc\n";
	  warn "Failed to parse irregular forms: $exc\n";
    }
  }

  # TEST
  #   if (s/_имеется прич\. страд\. наст\._(?:\s*\(_устар\._\)\s*(\w+)\s*)?//) {
  #     warn "OK: $word:$1:$_\n"
  #   }
  # везти 5 нсв 7в/в, Ё, _имеется прич. страд. наст._ (_устар._) везОмый
  # взбороздить 9 св 4в, _прич. страд._ взборождЁнный
  # искл::{'чпс'=>[{'с'=>'взборождённый','у'=>9}]}

  # склоняются обе части
  # both parts are declined
  if(s/,\s*_склоняются обе части_(?:\s*\((?:_как_\s*)?([^)]+)\))?//)
    { $props{'с2ч'} = ($1 or "") }

  # слово употребляется только в приводимых словосочетаниях
  # word is used only in the expressions indicated
  if(m/:/ && (m/^[^\(\[]*:/ || !m/[\(\[][^\)\]]*:.*[\)\]]/) && s/\s*:\s*(.*)$//)
    { $props{'слсч'} = $1 }

  # указание значения (замечания)
  # meaning of word (a note)
  if(s/\(_([^\)]*?)_?\)\s*//)
    { $props{'з'} = $1 }

  # дополнительное указание значения (замечания)
  # additional information about meaning (a note)
  if(s/\(_([^\)]*?)_?\)\s*//)
    { $props{'з2'} = $1 }

  # сведения о вариантах слова (замечания)
  if(s/\[_([^\]]+)\]//)
    { $props{'з3'} = $1 }

  s/^\s*//; s/\s*$//;

  # genitive plural is awkward
  if(s/_Р\. мн\. затрудн\._//)
    { $fzprops{'рм'} = "" }

  # genitive is awkward
  if(s/_Р\. затрудн\._//)
    { $fzprops{'рм'} = "" }

  # plural is awkward
  if(s/_мн\. затрудн\._//)
    { $fzprops{'.м'} = "" }

  # plural is awkward (except for the genitive case)
  if(s/_мн\. затрудн\., кроме Р\._//)
    { $fzprops{'[^р]м'} = "" }

  if(s/_кф м и ж затрудн\._//)
    { $fzprops{'к.ем'} = ""; $fzprops{'к.еж'} = "" }
  if(s/_кф м затрудн\._//)
    { $fzprops{'к.ем'} = "" }
  if(s/_кф ж затрудн\._//)
    { $fzprops{'к.еж'} = "" }
  if(s/_кф затрудн\. \(кроме кф м\)_//)
    { $fzprops{'к.е[^м]'} = ""; $fzprops{'к.м'} = "" }
  if(s/_кф затрудн\._//)
    { $fzprops{'к'} = "" }
  if(s/_кф и сравн\. затрудн\._//)
    { $fzprops{'к'} = ""; $fzprops{'с'} = "" }
  if(s/_сравн\. затрудн\._//)
    { $fzprops{'с'} = "" }
  if(s/_употр\. преимущ\. кф_//)
    { $fzprops{'[^к]'} = "" }
  if(s/_косв\. формы затрудн\._//)
    { $fzprops{'..'} = "" }
  if(s/_повел\. затрудн\._//)
    { $fzprops{'!..'} = "" }
  if(s/_деепр\. затрудн\._//)
    { $fzprops{'дн'} = "" }
  if(s/_повел\. и деепр\. затрудн\._//)
    { $fzprops{'дн'} = ""; $fzprops{'!..'} = "" }
  if(s/_наст\. 1 ед\. затрудн\._//)
    { $fzprops{'н1е'} = "" }
  if(s/_буд\. 1 ед\. затрудн\._//)
    { $fzprops{'б1е'} = "" }
  if(s/_буд\. избегается_//)
    { $fzprops{'б..'} = "" }
  if(s/_буд\. и прич\. страд\. избегаются_//)
    { $fzprops{'б..'} = ""; $fzprops{'ч.с'} = "" }
  if(s/_прич\. страд\. наст\. затрудн\._//)
    { $fzprops{'чнс'} = "" }

  if(s/_Р\. мн\. нет_//)
    { $fnprops{'рм'} = "" }
  if(s/_кф м нет_//)
    { $fnprops{'к.ем'} = "" }
  if(s/_кф и сравн\. нет_//)
    { $fnprops{'к'} = ""; $fnprops{'с'} = "" }
  if(s/_пф нет_//)
    { $fnprops{'п'} = "" }
  if(s/_употр\. ?только кф_//)
    { $fnprops{'[^к]'} = "" }
  if(s/_косв\. форм нет_//)
    { $fnprops{'..'} = "" }
  if(s/_кроме И\., форм нет_//)
    { $fnprops{'[^и][^е]'} = "" }
  if(s/_прич\. прош\. нет_//)
    { $fnprops{'чпд'} = "" }
  if(s/_прош\. нет, инф\. устаревш\._//)
    { $fnprops{'п'} = "" } # TODO: инф. устаревш.
  if(s/_прош\. нет, прочие формы устаревш\._//)
    { $fnprops{'п'} = "" } # TODO: прочие формы устаревш.
  if(s/_страд\. нет_//)
    { $fnprops{'ч.с'} = "" }
  if(s/_деепр\. нет_//)
    { $fnprops{'дн'} = "" }
  if(s/_имеется только наст\._//)
    { $fnprops{'[^н]'} = "" }
  if(s/_наст\. 1 ед\. нет_//)
    { $fnprops{'н1е'} = "" }
  if(s/_в лит\. языке наст\. и буд\. нет_//)
    { $fnprops{'б..'} = ""; $fnprops{'н..'} = "" }
  if(s/_буд\. в лит\. языке нет_//)
    { $fnprops{'б..'} = "" }
  if(s/_буд\. нет_//)
    { $fnprops{'б..'} = "" }
  if(s/_буд\. 1 ед\. нет_//)
    { $fnprops{'б1е'} = "" }
  if(s/_прич\. страд\._ -([^-]+)-//)
    { $props{'гпс'} = ($1 or "") }
  if(s/,\s*многокр\.//)
    { $props{'гмн'} = "" }
  if(s/,\s*безл\.//)
    { $props{'гбл'} = "" }

  # множественное число
  if (s/^мн\.\s*(_от_|неод\.|одуш\.)?\s*//) {
    if (defined $1) {
      if ($1 eq "одуш.") { @props{'т','о','мн'} = ("с", "о", "") }
      elsif ($1 eq "неод.") { @props{'т','о','мн'} = ("с", "н", "") }
      elsif ($1 eq "_от_") {
        if (s/^(\w\w+)\s*//) { $props{'мн'} = $1 }
        else { $props{'мн'} = "от" }
      }
    } else { $props{'мн'} = ($1 or "") }
  }

  # факультативные отклонения от стандартного склонения
  if(s/\[((?:"\d+")+)\]//)
    {
    my $osf = $1;
    $osf =~ s/\"//g;
    $props{'осф'} = $osf;
    }

  # exception the the standard declension (TODO: indicated by what?)
  # отклонения от стандартного склонения
  if(s/((?:"\d+")+)//)
    {
    my $os = $1;
    $os =~ s/\"//g;
    $props{'ос'} = $os;
    }

  # чередование ё/е
  if(s/,\s*Ё\s*//)
    { $props{'чё'} = "" }

  # чередование о/е
  if(s/,\s*о\s*//)
    { $props{'чо'} = "" }

  # 2nd genitive case
  # 2-й родительный падеж
  if(s/,\s*[Рр]2\s*//)
    { $props{'р2'} = "" }

  # 2nd prepositional case
  # 2-й предложный падеж
  if(s/,\s*[Пп]2(?: ?\((во?|на)\))?\s*//)
    { $props{'п2'} = ($1 or "") }

  # 2-й предложный падеж факультативный
  if(s/,\s*\[[Пп]2(?: ?\((во?|на)\))?\]\s*//)
    { $props{'п2ф'} = ($1 or "") }

  # определённые чередования
  if(!m/^[^*]*мн\./ && s/\*\*//)
    { $props{'ч2'} = "" }

  # чередование беглой гласной с нулём
  if(!m/^[^*]*мн\./ && s/\*//)   { $props{'ч'} = "" }

  # прочие чередования
  if(s/\(-(.{1,2})-\)//)
    { $props{'ч3'} = $1 }

  # форма затруднительна
  if(s/\!//)
    { $fz = "" }

  # формы нет
  if(s/\?//)
    { $fn = "" }

  # сравнительной степени нет
  if(s/\~//)
    { $fnprops{'с'} = "" }

  s/,?\s*$//;

  # form is hypothetical
  # форма предположительна
  if(s/\-$//)
    { $fp = "" }

  # 'и' - тип склонения/спряжения (индекс), 'у[12]' - схема ударения
  if(s/0\s*$//)
    { $props{'и'} = "0"; }
  elsif(s|(\d{1,2})([авсDеF](?:\'{1,2})?)(/[авсDеF](?:\'{1,2})?)?||) {
    $props{'и'} = $1;
    my $ud1 = $2;
    if (defined $3) {
      my $ud2 = $3; $ud2 =~ s(/)();
      $ud2 =~ tr/авсDеF/abcdef/; $ud2 =~ s/\'\'/2/; $ud2 =~ s/\'/1/;
      $props{'у2'} = $ud2;
    }
    $ud1 =~ tr/авсDеF/abcdef/; $ud1  =~ s/\'\'/2/; $ud1  =~ s/\'/1/;
    $props{'у1'} = $ud1;
  }
  if (s/^(н?св(?:-нсв)?)\s*(нп)?\s*//) {
    $props{'т'} = "г"; $props{'гв'} = $1;
    $props{'гп'} = $2 || $word =~ /с[яь]$/ && "нп" || "п";
  }

  s/(мо-жо) жо/$1/; # у общего рода морф.род всегда женский

  s/,?\s*//;

  if (s|^([мжс])о?//\1о?,?||) {
    ($props{'т'}, $props{'р'}, $props{'о'}) = ("с", $1, "но");
  } elsif (s|^([мжс])(о?)//([мжс])(о?),?||) {
    if ($1 ne $3 && $2 eq $4) {
      @props{'т','р'} = ("с", "$1$3");
      $props{'о'} = (defined $2 && $2 ne "") && "о" || "н";
    } else { warn "$word: разный род должен быть с одинаковой одушевлённостью: $o\n" }
  } elsif (s/^мо-жо//) {
    @props{'т','р','о','рм'} = ("с", "о", "о", "ж"); # о = общ.род
  } elsif (s/^([мжс])(о)?(?![юресо])//) {
    @props{'т','р'} = ("с", $1); $props{'о'} = $2 if defined $2;
  } elsif (s/^(п|мс-п|мс|числ\.-п)(?![р])//) {
    my $chr = $1; $chr =~ s/\.//;
    if (!defined $props{'т'}) { $props{'т'} = $chr } # т (тип) - часть речи
    else { $props{'т2'} = $chr } # тип склонения
  } elsif (s/^(н|предик\.|межд\.|предл\.|част\.|союз|вводн\.|сравн\.|числ\.)//) {
    my $chr = $1; $chr =~ s/\.//; $props{'т'} = $chr; $props{'и'} = "0";
  } elsif (s/предикативное мс//) {
    $props{'т'} = "мс";
  }
  if (s/^ //) {
    if (s/^([мжс])(о)?(?![с])//) {
      if (!defined $props{'р'}) { $props{'р'} = $1 }
      else { $props{'рм'} = $1 } # морф.род
      $props{'о'} = $2 if (!defined $props{'о'} && defined $2);
    } elsif (s/^(п|мс-п|мс|числ\.-п)//) {
      my $chr = $1; $chr =~ s/\.//;
      if (!defined $props{'т'}) { $props{'т'} = $chr }
      else { $props{'т2'} = $chr } # тип склонения
    }
  }

  s/^\s*//;

  # форма предположительна
  if(s/^\-//)
    { $fp = "" }

  if(s/\((\w+)-\)// && $props{'т'} eq "г")
    { $props{'сб'} = $1 }

  # дополнительное указание значения (замечания)
  if(s/(_см. также( отдельно)?_ \w+)//) # TODO: (_сочетается .*_)
    { $props{'з2'} .= $1 }

  # extension to format
  # #HUB: noun
  # #ENG: English word
  # #EX: example
  while(s/\(#?([A-Z_-]+): ([^\)]+)\)//g)
    {
    }

  if(s/М\(([^\)]+)\)//)
	{
	}

  if(s/П2\(([^\)]+)\)//)
	{
	}

  s/^[\s,;]+//;

  if ($_ ne "") {
    # если часть строки осталась необработанной
    if(defined $props{'т'} && $props{'т'} eq "числ") {
      # склонение числительных берётся из файла исключений
      $props{'т2'} = "ч";
      my $exc = "$word: $_";
      #$excp = $lineh{$exc};
      #$excp or warn "Склонение числительного не найдено в файле $x_subpatch: $exc\n";
      #(defined $excp) && ($exc eq $excp) && (undef $excp, 1) &&
      #  warn "Склонение числительного заменяется старой строкой: \@$exc\n";
	  warn "Склонение числительного отсутсвует: \@$exc\n";
    } else {
      # сообщить заглавное слово, необработанную часть строки и оригинальую строку
      warn "$word <> $_ <> $o\n"; # next
    }
  }

  if (defined $fp) {           # форма предположительна
    if ($props{'т'} eq "п") { $props{'фп'} = "к.ем" }
    elsif ($props{'т'} eq "с") { $props{'фп'} = ".м" }
  }

  if (defined $fz) {           # форма затруднительна
    if ($props{'т'} eq "г") { $fzprops{'чпс'} = "" }
    elsif ($props{'т'} eq "п") { $fzprops{'к'} = "" }
  }

  if (defined $fn) {           # формы нет
    if ($props{'т'} eq "г") { $fnprops{'чпс'} = "" }
    elsif ($props{'т'} eq "п") { $fnprops{'к.ем'} = ""; $fzprops{'к'} = "" }
  }

  if (%fzprops) { $props{'фз'} = "^".join("|^", sort(keys %fzprops)) }
  if (%fnprops) { $props{'фн'} = "^".join("|^", sort(keys %fnprops)) }

  print "с:$word", (map {
    "\t$_" . ($props{$_} ne "" ? ":" . $props{$_} : "")
  } sort {
    index($sort_order, " $b ") <=> index($sort_order, " $a ")
    or $a cmp $b
  } keys %props),
  (defined $excp && "\tискл::$excp"), "\n";
}

close(ZALIZ) || die $!;
